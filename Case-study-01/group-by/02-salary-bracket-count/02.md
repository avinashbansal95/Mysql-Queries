# Department Salary Bracket Analysis with CASE

## Problem Statement

For each department, count how many employees fall into:
* **Low**: salary < 55,000
* **Medium**: 55,000 ≤ salary ≤ 65,000
* **High**: salary > 65,000

**Output**:
- `dept_name`
- `low_count`
- `medium_count`
- `high_count`

We'll use:
* `GROUP BY dept_id`
* `CASE` inside `SUM()` to **conditionally count**
* `LEFT JOIN` with `departments` to include **all departments**, even if no employees (optional, but good practice)

## ✅ Step-by-Step Solution

### 🔹 Step 1: Categorize Each Employee Using `CASE`

We want to assign each employee to a bracket:

```sql
CASE
    WHEN salary < 55000 THEN 1 ELSE 0
END → for low_count
```

But we don't want to create a column — we want to **count** how many fall into each.

So we use:
```sql
SUM(CASE WHEN salary < 55000 THEN 1 ELSE 0 END) AS low_count
```

This trick is called **conditional aggregation** — very common in interviews.

### 🔹 Step 2: Group by Department

We'll group by `dept_id`, then join with `departments` to get `dept_name`.

### 🔹 Step 3: Handle Departments with Zero Employees (Optional but Strong)

Use `LEFT JOIN` from `departments` to ensure all departments appear.

## ✅ Final Query:

```sql
SELECT
    d.dept_name,
    COALESCE(SUM(CASE WHEN e.salary < 55000 THEN 1 ELSE 0 END), 0) AS low_count,
    COALESCE(SUM(CASE WHEN e.salary >= 55000 AND e.salary <= 65000 THEN 1 ELSE 0 END), 0) AS medium_count,
    COALESCE(SUM(CASE WHEN e.salary > 65000 THEN 1 ELSE 0 END), 0) AS high_count
FROM departments d
LEFT JOIN employees e ON d.dept_id = e.dept_id
GROUP BY d.dept_id, d.dept_name
ORDER BY d.dept_name;
```

## 🔍 Why This Works

| Part | Explanation |
|------|-------------|
| `CASE WHEN ... THEN 1 ELSE 0 END` | Creates a flag for each bracket |
| `SUM(...)` | Counts how many employees match each condition |
| `LEFT JOIN` | Ensures departments with no employees still appear |
| `GROUP BY d.dept_id, d.dept_name` | Required when using `GROUP BY` with non-aggregated columns |
| `COALESCE(..., 0)` | Converts `NULL` → `0` for empty departments |

## 🧪 Example Output (Based on Your Data)

Let's go through real values:

| emp_name | salary | dept | Category |
|----------|---------|------|----------|
| Alice | 70,000 | Engineering | High |
| Bob | 60,000 | Engineering | Medium |
| Charlie | 65,000 | Sales | Medium |
| David | 55,000 | Engineering | Medium |
| Eve | 62,000 | Sales | Medium |
| Frank | 50,000 | Marketing | Low |
| Grace | 58,000 | HR | Medium |
| Henry | 72,000 | Engineering | High |
| Ivy | 54,000 | Marketing | Low |
| Jack | 61,000 | Sales | Medium |
| Kate | 53,000 | Finance | Low |
| Leo | 67,000 | Engineering | High |

Now group by department:

| dept_name | low_count | medium_count | high_count |
|-----------|-----------|--------------|------------|
| Engineering | 0 | 2 (Bob, David) | 3 (Alice, Henry, Leo) |
| Sales | 0 | 3 (Charlie, Eve, Jack) | 0 |
| Marketing | 2 (Frank, Ivy) | 0 | 0 |
| HR | 0 | 1 (Grace) | 0 |
| Finance | 1 (Kate) | 0 | 0 |

## 💡 Pro Tips for Interviews

1. ✅ **Use `COALESCE`** when using `LEFT JOIN` + `SUM` — `SUM()` of no rows is `NULL`, not `0`.

2. ✅ **Use `>= 55000 AND <= 65000`** to be precise. Don't use overlapping or gaps.

3. ✅ **Avoid `COUNT(CASE ...)`** — `COUNT` counts non-nulls, so:
   ```sql
   COUNT(CASE WHEN salary < 55000 THEN 1 END) -- OK
   ```
   But `SUM(... THEN 1 ELSE 0 ...)` is clearer for beginners.

4. ✅ **Group by `dept_id, dept_name`** — MySQL allows it, and it's safe.

## 🚀 Bonus: What if you wanted % of each bracket?

```sql
ROUND(
    100.0 * SUM(CASE WHEN salary < 55000 THEN 1 ELSE 0 END) / COUNT(e.emp_id), 2
) AS low_percentage
```

## Alternative Approaches

### Using COUNT instead of SUM:
```sql
SELECT
    d.dept_name,
    COUNT(CASE WHEN e.salary < 55000 THEN 1 END) AS low_count,
    COUNT(CASE WHEN e.salary >= 55000 AND e.salary <= 65000 THEN 1 END) AS medium_count,
    COUNT(CASE WHEN e.salary > 65000 THEN 1 END) AS high_count
FROM departments d
LEFT JOIN employees e ON d.dept_id = e.dept_id
GROUP BY d.dept_id, d.dept_name
ORDER BY d.dept_name;
```

### Including percentage calculations:
```sql
SELECT
    d.dept_name,
    COALESCE(SUM(CASE WHEN e.salary < 55000 THEN 1 ELSE 0 END), 0) AS low_count,
    COALESCE(SUM(CASE WHEN e.salary >= 55000 AND e.salary <= 65000 THEN 1 ELSE 0 END), 0) AS medium_count,
    COALESCE(SUM(CASE WHEN e.salary > 65000 THEN 1 ELSE 0 END), 0) AS high_count,
    COUNT(e.emp_id) AS total_employees,
    CASE 
        WHEN COUNT(e.emp_id) = 0 THEN 0
        ELSE ROUND(100.0 * SUM(CASE WHEN e.salary < 55000 THEN 1 ELSE 0 END) / COUNT(e.emp_id), 1)
    END AS low_percentage
FROM departments d
LEFT JOIN employees e ON d.dept_id = e.dept_id
GROUP BY d.dept_id, d.dept_name
ORDER BY d.dept_name;
```

## Key Takeaways

- **Conditional Aggregation**: `SUM(CASE WHEN condition THEN 1 ELSE 0 END)` is a powerful pattern
- **LEFT JOIN**: Ensures all departments are included, even without employees
- **COALESCE**: Handles NULL values from empty groups
- **Clear Conditions**: Use precise range definitions to avoid overlaps or gaps